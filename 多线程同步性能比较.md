多线程同步方式性能比较
===
前言
---
多线程同步数据的时候第一反应就是加锁，一直知道加锁会导致性能损失，
一直没有一个量化的概念，在为核心安全情报中心增加统计每天处理条数的
时候统计了下，下面直接说结论：
> 耗时统计：原子操作 < 无锁 < 加锁
> 无锁耗时是原子操作的3倍左右，加锁耗时为原子操作的10倍左右
> 竞争越多，性能越差，60协程的时候与单协程代码相比耗时增加了100倍

**推荐做法**：
> 1， 尽可能避免使用锁，如果避免不了竞争状态，优先考虑使用原子操作(golang中sync/atomic，和c++11提供的atomic模板)；
>
> 2， 避免多协程去竞争，推荐每个协程一个对象实例(当然需要结合具体的应用场景，我的是最后由redis来计算总和，因此可以每个协程一个计数实例)


以下是几组测试数据，单位为(ns/op)：

||单协程|61个协程|
|---|---|---|
|无锁|398||
||396||
||400||
||396||
|加锁(mutex)|1184|113250|
||1159|166870|
||1184|184134|
||1193|168281|
|原子|127|12121|
||126|12500|
||127|13786|
||126|11432|
其中无锁版本多协程测试没有意义，因此没测



